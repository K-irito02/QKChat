# Qt6 QML 编程规范与最佳实践指南

## 目录
1. [基础规范](#基础规范)
2. [命名约定](#命名约定)
3. [代码组织结构](#代码组织结构)
4. [属性声明规范](#属性声明规范)
5. [信号与槽处理](#信号与槽处理)
6. [JavaScript 函数规范](#javascript-函数规范)
7. [性能优化最佳实践](#性能优化最佳实践)
8. [布局与定位](#布局与定位)
9. [组件生命周期管理](#组件生命周期管理)
10. [类型安全与错误处理](#类型安全与错误处理)
11. [国际化支持](#国际化支持)
12. [资源管理](#资源管理)
13. [调试与工具](#调试与工具)

---

## 基础规范

### 文件命名
- **QML文件**: 使用 PascalCase 命名 (LoginPage.qml, CustomButton.qml, MessageDialog.qml)
- **JavaScript文件**: 使用 camelCase 命名 (utils.js, networkHelper.js)
- **资源文件**: 使用小写字母和连字符 (app-icon.png, background-image.jpg)

### 导入语句规范
```qml
// 系统模块导入
import QtQuick 2.15
import QtQuick.Controls 2.15
import QtQuick.Layouts 1.15

// 第三方模块导入
import QtQuick.Controls.Material 2.15

// 项目自定义模块导入
import "../components" as Components
import "../utils/networkHelper.js" as NetworkHelper
```

---

## 命名约定

### 组件ID命名
- 使用 camelCase 命名
- 名称应具有描述性和唯一性
```qml
Rectangle {
    id: mainContainer
    
    Button {
        id: loginButton
        text: "登录"
    }
    
    TextField {
        id: usernameField
        placeholderText: "用户名"
    }
}
```

### 属性命名
- **自定义属性**: camelCase (isLoading, errorMessage, connectionState)
- **信号名称**: on前缀 + PascalCase (onLoginClicked, onTextChanged, onConnectionLost)
- **函数名称**: camelCase (calculateWidth, handleResponse, validateInput)

---

## 代码组织结构

### 推荐的QML对象结构顺序
```qml
Rectangle {
    // 1. ID声明 (必须在第一行)
    id: photoContainer

    // 2. 属性声明
    property bool thumbnail: false
    property alias image: photoImage.source
    property string title: ""

    // 3. 信号声明
    signal clicked(var mouse)
    signal imageLoaded()

    // 4. JavaScript函数
    function calculateAspectRatio(width, height) {
        return width / height
    }

    function handleImageLoad() {
        imageLoaded()
    }

    // 5. 对象属性 (按相关性分组)
    color: "lightgray"
    width: thumbnail ? 100 : 300
    height: thumbnail ? 100 : 300
    radius: 8

    // 6. 状态和过渡
    states: [
        State {
            name: "selected"
            PropertyChanges { target: border; color: "blue" }
        }
    ]

    transitions: [
        Transition {
            from: ""
            to: "selected"
            ColorAnimation { target: border; duration: 200 }
        }
    ]

    // 7. 子对象
    Rectangle {
        id: border
        anchors.fill: parent
        color: "transparent"
        border.width: 2
        border.color: "gray"

        Image {
            id: photoImage
            anchors.centerIn: parent
            fillMode: Image.PreserveAspectFit
            onStatusChanged: {
                if (status === Image.Ready) {
                    handleImageLoad()
                }
            }
        }
    }

    // 8. 组件生命周期处理
    Component.onCompleted: {
        console.log("PhotoContainer initialized")
    }

    Component.onDestruction: {
        console.log("PhotoContainer destroyed")
    }
}
```

---

## 属性声明规范

### 类型安全的属性声明
```qml
// ❌ 避免使用 var 类型
property var name
property var size
property var optionsMenu

// ✅ 使用明确的类型声明
property string name: ""
property int size: 0
property MyCustomMenu optionsMenu
```

### 属性分组
```qml
// ✅ 使用分组语法提高可读性
Rectangle {
    // 锚点分组
    anchors {
        left: parent.left
        top: parent.top
        right: parent.right
        leftMargin: 20
    }
}

Text {
    text: "Hello World"
    // 字体分组
    font {
        bold: true
        italic: true
        pixelSize: 20
        capitalization: Font.AllUppercase
    }
}
```

### 属性绑定最佳实践
```qml
// ✅ 优先使用声明式绑定
Rectangle {
    color: "red"
    width: parent.width * 0.8
    height: parent.height * 0.6
}

// ❌ 避免在Component.onCompleted中设置属性
Rectangle {
    Component.onCompleted: {
        color = "red"  // 这会破坏绑定
        width = parent.width * 0.8
    }
}
```

---

## 信号与槽处理

### 信号处理器命名
```qml
MouseArea {
    // ✅ 使用显式参数命名
    onClicked: event => {
        console.log(`点击位置: ${event.x}, ${event.y}`)
        handleClick(event)
    }
    
    onPressed: mouse => {
        console.log("鼠标按下")
    }
}

// ✅ 属性变化信号处理
TextInput {
    text: "Change this!"
    
    onTextChanged: {
        console.log(`文本已更改为: ${text}`)
        validateInput(text)
    }
}
```

### 自定义信号
```qml
Item {
    // 信号声明
    signal userAuthenticated(string username, bool success)
    signal dataReceived(var data)
    signal errorOccurred(string errorMessage, int errorCode)
    
    function login(username, password) {
        // 登录逻辑
        if (loginSuccess) {
            userAuthenticated(username, true)
        } else {
            errorOccurred("登录失败", 401)
        }
    }
}
```

---

## JavaScript 函数规范

### 函数定义与类型注解
```qml
// ✅ 带类型注解的函数
function calculateWidth(object: Item): real {
    var w = object.width / 3
    console.debug(`计算宽度: ${w}`)
    return w
}

function validateEmail(email: string): bool {
    var emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
    return emailRegex.test(email)
}

function formatUserData(user: var): string {
    return `${user.name} (${user.email})`
}
```

### 外部JavaScript文件
```javascript
// utils/mathHelper.js
.pragma library

function calculateAspectRatio(width, height) {
    if (height === 0) return 0
    return width / height
}

function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value))
}
```

```qml
// 在QML中使用
import "utils/mathHelper.js" as MathHelper

Rectangle {
    width: 200
    height: MathHelper.calculateAspectRatio(width, 150) * width
}
```

---

## 性能优化最佳实践

### 属性绑定优化
```qml
// ❌ 低效的重复属性解析
Item {
    Component.onCompleted: {
        for (var i = 0; i < 1000; ++i) {
            console.log("red:", rect.color.r)
            console.log("green:", rect.color.g)
            console.log("blue:", rect.color.b)
        }
    }
}

// ✅ 优化的属性解析
Item {
    Component.onCompleted: {
        var rectColor = rect.color  // 在循环外解析
        for (var i = 0; i < 1000; ++i) {
            console.log("red:", rectColor.r)
            console.log("green:", rectColor.g)
            console.log("blue:", rectColor.b)
        }
    }
}
```

### 中间绑定优化
```qml
// ✅ 使用中间属性减少重复计算
Item {
    property int intermediateValue: complexCalculation.result
    property int firstBinding: intermediateValue + 10
    property int secondBinding: intermediateValue + 20
    property int thirdBinding: intermediateValue + 30
}
```

### 累积操作优化
```qml
// ❌ 低效的累积操作
Item {
    property int accumulatedValue: 0
    
    Component.onCompleted: {
        var data = [1, 2, 3, 4, 5]
        for (var i = 0; i < data.length; ++i) {
            accumulatedValue = accumulatedValue + data[i]  // 每次都触发绑定
        }
    }
}

// ✅ 优化的累积操作
Item {
    property int accumulatedValue: 0
    
    Component.onCompleted: {
        var data = [1, 2, 3, 4, 5]
        var temp = accumulatedValue
        for (var i = 0; i < data.length; ++i) {
            temp = temp + data[i]
        }
        accumulatedValue = temp  // 只触发一次绑定
    }
}
```

---

## 布局与定位

### 锚点系统 vs 直接定位
```qml
// ✅ 推荐使用锚点系统
Rectangle {
    id: rect1
    x: 20
    width: 200
    height: 200
}

Rectangle {
    id: rect2
    height: 200
    anchors {
        left: rect1.left
        top: rect1.bottom
        right: rect1.right
        rightMargin: 20
    }
}

// ❌ 避免复杂的绑定表达式
Rectangle {
    id: rect2
    x: rect1.x
    y: rect1.y + rect1.height
    width: rect1.width - 20
    height: 200
}
```

### 静态定位优化
```qml
// ✅ 对于固定布局，静态定位最高效
Rectangle {
    width: 60
    height: 60
    
    Rectangle {
        id: fixedChild
        x: 20
        y: 20
        width: 20
        height: 20
    }
}
```

---

## 组件生命周期管理

### Component.onCompleted 最佳实践
```qml
Item {
    id: root
    
    property bool isInitialized: false
    
    Component.onCompleted: {
        console.log("组件初始化开始")
        
        // 初始化网络连接
        networkManager.initialize()
        
        // 连接信号
        networkManager.dataReceived.connect(handleDataReceived)
        networkManager.errorOccurred.connect(handleError)
        
        // 加载初始数据
        loadInitialData()
        
        isInitialized = true
        console.log("组件初始化完成")
    }
    
    Component.onDestruction: {
        console.log("组件销毁开始")
        
        // 断开信号连接
        networkManager.dataReceived.disconnect(handleDataReceived)
        networkManager.errorOccurred.disconnect(handleError)
        
        // 清理资源
        networkManager.cleanup()
        
        console.log("组件销毁完成")
    }
    
    function handleDataReceived(data) {
        if (!isInitialized) return
        // 处理数据
    }
    
    function handleError(error) {
        console.error("网络错误:", error)
    }
}
```

### 避免循环变量冲突
```qml
// ❌ 变量名冲突
Component.onDestruction: {
    for (var i = 0; i < userWindows.length; ++i) {
        userWindows[i].close()
    }
    for (var i = 0; i < friendWindows.length; ++i) {  // 变量名冲突
        friendWindows[i].close()
    }
}

// ✅ 使用不同的变量名
Component.onDestruction: {
    for (var i = 0; i < userWindows.length; ++i) {
        userWindows[i].close()
    }
    for (var j = 0; j < friendWindows.length; ++j) {
        friendWindows[j].close()
    }
}
```

---

## 类型安全与错误处理

### 显式类型声明
```qml
Item {
    // ✅ 明确的类型声明
    property string username: ""
    property int userId: -1
    property bool isLoggedIn: false
    property url avatarUrl: ""
    property list<string> permissions: []
    property MyCustomType customObject
    
    // ✅ 函数参数类型注解
    function updateUser(id: int, name: string, active: bool): bool {
        if (id <= 0 || name.length === 0) {
            console.error("无效的用户参数")
            return false
        }
        
        userId = id
        username = name
        isLoggedIn = active
        return true
    }
}
```

### 错误处理模式
```qml
Item {
    property string errorMessage: ""
    property bool hasError: false
    
    function handleNetworkResponse(response) {
        try {
            if (!response || response.error) {
                setError(response ? response.error : "网络请求失败")
                return
            }
            
            clearError()
            processSuccessResponse(response)
        } catch (e) {
            setError(`处理响应时出错: ${e.message}`)
        }
    }
    
    function setError(message) {
        errorMessage = message
        hasError = true
        console.error("错误:", message)
    }
    
    function clearError() {
        errorMessage = ""
        hasError = false
    }
}
```

---

## 国际化支持

### 字符串翻译
```qml
Button {
    // ✅ 使用 qsTr() 标记可翻译字符串
    text: qsTr("登录")
    
    ToolTip.text: qsTr("点击此按钮登录到系统")
    
    onClicked: {
        showMessage(qsTr("正在登录，请稍候..."))
    }
}

Text {
    // ✅ 带上下文的翻译
    text: qsTr("File", "menu")
}

Text {
    // ✅ 复数形式翻译
    text: qsTr("%n item(s) selected", "", selectedCount)
}
```

### 动态语言切换
```qml
ApplicationWindow {
    id: window
    
    property string currentLanguage: "zh_CN"
    
    function changeLanguage(language) {
        currentLanguage = language
        // 触发界面重新翻译
        Engine.retranslate()
    }
    
    MenuBar {
        Menu {
            title: qsTr("语言")
            
            MenuItem {
                text: qsTr("中文")
                onTriggered: changeLanguage("zh_CN")
            }
            
            MenuItem {
                text: qsTr("English")
                onTriggered: changeLanguage("en_US")
            }
        }
    }
}
```

---

## 资源管理

### 资源文件组织
```qml
// ✅ 使用资源系统
Image {
    source: "qrc:/images/icons/user-avatar.png"
}

Button {
    icon.source: "qrc:/images/buttons/login-icon.svg"
}

// ✅ 相对路径引用
Image {
    source: "../assets/images/background.jpg"
}
```

### 图片资源优化
```qml
Image {
    id: profileImage
    source: "qrc:/images/default-avatar.png"
    
    // 性能优化设置
    asynchronous: true
    cache: true
    fillMode: Image.PreserveAspectCrop
    
    // 加载状态处理
    onStatusChanged: {
        switch (status) {
        case Image.Loading:
            loadingIndicator.visible = true
            break
        case Image.Ready:
            loadingIndicator.visible = false
            break
        case Image.Error:
            source = "qrc:/images/error-placeholder.png"
            loadingIndicator.visible = false
            break
        }
    }
}
```

---

## 调试与工具

### 调试输出规范
```qml
Item {
    function debugLog(message, level = "INFO") {
        var timestamp = new Date().toISOString()
        console.log(`[${timestamp}][${level}]: ${message}`)
    }
    
    function handleUserAction(action) {
        debugLog(`用户执行操作: ${action}`, "DEBUG")
        
        try {
            processAction(action)
            debugLog(`操作 ${action} 执行成功`)
        } catch (error) {
            debugLog(`操作 ${action} 执行失败: ${error.message}`, "ERROR")
        }
    }
}
```

### 性能监控
```qml
Item {
    function measurePerformance(operationName, operation) {
        var startTime = new Date()
        
        try {
            var result = operation()
            var endTime = new Date()
            var duration = endTime.valueOf() - startTime.valueOf()
            
            console.log(`${operationName} 耗时: ${duration}ms`)
            return result
        } catch (error) {
            console.error(`${operationName} 执行出错:`, error)
            throw error
        }
    }
    
    Component.onCompleted: {
        measurePerformance("初始化数据", function() {
            return loadInitialData()
        })
    }
}
```

---

## 总结

本规范涵盖了Qt6 QML开发的核心最佳实践，包括：

1. **代码组织**: 清晰的文件结构和命名约定
2. **性能优化**: 高效的属性绑定和布局策略
3. **类型安全**: 明确的类型声明和错误处理
4. **生命周期管理**: 正确的组件初始化和清理
5. **国际化支持**: 完整的多语言解决方案
6. **调试工具**: 有效的调试和性能监控方法

遵循这些规范将帮助您构建高质量、高性能、易维护的QML应用程序。在QKChat项目中，我们严格按照这些标准进行开发，确保代码质量和用户体验。